Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (gamefile publication, negotiation, play) into a pub-sub model:
Message(C,H,P,T):
 Does anyone want to play a choose-your-own Adventure game on channel C (which serves as a game ID)
 using the multiplayer turn-attributed grammar G which has MD5 hash H,
  with [possibly incomplete] player list P
   (a vector, where the n'th entry is null or (playerPublicKey + signature of (C,H) + optional P[1] signature))
  starting from rooted parse subtree T?
 If so, and
   your augmented player-lists and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,H,P',T').
 Some subset of the player list is signed by P[1], the first player (must be all if message originates from P[1]).
 Each internal node of T is signed (cryptographically) by the player who expanded that node.
[if P is incomplete for G, rebroadcast on channel 'join/G.name' as well as C, where G.name is the name of the grammar]
[if G.private==true, then (T,Q) parameters of message are encrypted so that only members of P can read.]


GrammarRequest(H) on channel "grammar/H"
GrammarResponse(H) on channel "grammar/H/response"



Client has four modes: "edit", "join", "wait" and "play".
Let
 S = {self}, i.e. set containing own player key & nothing else,
 I = [self,null,null...], i.e. initial player list with self as player #1 and no other players,
 R = {G.rootNonterminal}.

In "edit" mode:
On clicking "Start game",
 let C = "play/G.name/RandomNumber",
 broadcast Message(C,H,I,R) on channels {C,"join/G.name"}, subscribe to channels C and "grammar/H",
 if G is single-player,
   go to "play" mode with state (H,I,R),
  otherwise,
   go into "wait" mode with state (H,I,R).
On clicking "Join game",
 subscribe to channel "join",
 go into "join" mode.
On clicking "Test game",
 go into "play" mode with state (H,I,R).

In "join" mode:
On receipt of Message(C,H,P,T):
 add (C,H,P,T,G.name or "anonymous game") to selectable game list.
On selecting game (C,H,P,T...) from the game list:
 broadcast Message(C,H,P',T) where P' is P with self written into next available player role,
 unsubscribe from channel "join",
 subscribe to channel C,
 go into "wait" mode with state (H,P',T).
On editing the grammar,
 unsubscribe from all channels,
 go into "edit" mode.

In "wait" mode with current state (H,P0,T0):
On receipt of Message(C,H,P,T),
 where P0 \subseteq P and T0 is consistent with T:
 if message signature is incomplete and P[1] = self,
  sign Message(C,H,P,T) and rebroadcast;
 if P has all players and (P[1] = self or message is signed by P[1]),
    render initial tree T,
    go to "play" mode with state (H,P,T).
  otherwise (still need more players or player1 signature),
   verify that T = T0,
   go to "wait" mode with state (H,P,T).
On editing the grammar,
 unsubscribe from all channels,
 go into "edit" mode.

In "play" mode with current state (H,P,T0):
On receipt of Message(C,H,P,T),
 where T0 is consistent with T:
 let T' = union(T0,T),
 if T' != T0,
  render new tree T'.
On expanding T0->T,
  render new tree T,
  broadcast Message(C,H,P,T) on channel C,
  go to "play" mode with state (H,P,T).
On editing the grammar,
 unsubscribe from all channels,
 go into "edit" mode.


On receiving a "GrammarRequest" on channel grammar/H in any mode,
 broadcast a "GrammarResponse", including grammar G, on channel grammar/H/response.


Core engine enhancements:
 Compact JSON representation of parse tree
 Extend turn-attributed grammar language to flag nonterminals as being player1, player2, ..., playerN, or nextPlayer (the player whose player number is one higher than the parent, modulo N)
  Add new "Player Number" to nonterminal editor
 N player score variables (evenly spaced along one line)
 LetterWriter language/model extensions:
  "players N"
  player prefix to rule ("#1", "#2", or nothing for "next")
  "$x#" expands to "$x".(currentPlayerNumber)
  "score $score" implies $score1,$score2...$scoreN


The first implementation doesn't need hashes, encryption or signatures;
"signing" can be a single (forgeable) bit.
Proper crypto can be added using this library:
http://openpgpjs.org/
