Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (gamefile publication, negotiation, play) into a pub-sub model:
Message(C,H,P,T):
 Does anyone want to play a choose-your-own Adventure game with channel parameter C (which serves as a game ID)
 using the multiplayer turn-attributed grammar G which has MD5 hash H,
  with [possibly incomplete] player list P
   (a vector, where the n'th entry is null or (playerPublicKey + signature of (C,H) + optional P[1] signature))
  starting from rooted parse subtree T?
 If so, and
   your augmented player-lists and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,H,P',T').
 Some subset of the player list is signed by P[1], the first player (must be all if message originates from P[1]).
 Each internal node of T is signed (cryptographically) by the player who expanded that node.

{ channel: C,
  hashgram: H,
  grammar: G,  // or grammar:null for GrammarRequest
  player: [ { key: PUBLICKEY_OF_PLAYER1, sig: PLAYER1_SIGNATURE_OF_CH },
  	    { key: PUBLICKEY_OF_PLAYER2, sig: PLAYER2_SIGNATURE_OF_CH, ack: PLAYER1_SIGNATURE_OF_sig },
  	    { key: PUBLICKEY_OF_PLAYER3, sig: PLAYER3_SIGNATURE_OF_CH, ack: PLAYER1_SIGNATURE_OF_sig } ],
  tree: { name:"start", type:"nonterm", choice:3, owner:1, sig:PLAYER1_SIGNATURE_OF_PATH,
          child: [ null, { name:"opening", type:"nonterm", choice:2, owner:2, sig:PLAYER2_SIGNATURE_OF_PATH,
                           child: [ null, null, null, { name:"salutation", type:"nonterm", owner:3 } ... ] } ...] } }

  	      

GrammarRequest(H).  // a Message containing only hashgram:H
GrammarResponse(G).  // a Message containing only hashgram:H and grammar:G
Quit(C).  // a Message with quit:true


Channels:
join
join/H/C/ROLE1ID/ROLE2ID/ROLE3ID...
quit/H/C/~ROLE/ID
grammar
grammar/H
grammar/H/C
game
game/H
game/H/C
game/H/C/join/ROLE1ID/ROLE2ID/.../NEWROLEID
game/H/C/request
game/H/C/play/ROLE1ID/ROLE2ID/.../ROLENID/~ROLE/@nonterm/cCHOICE/sSIBLING/@nonterm/cCHOICE/sSIBLING...


TODO: convert the following from state-machine to event-driven callbacks that subscribe to/unsubscribe from various channels, and present/hide various interfaces


Client has five states: "edit", "join", "start-wait(C,H,P,T)", "join-wait(C,H,G,P,T)", and "play(C,H,G,P,T)".
Let
 SELF = crypto identifier, e.g. public key, or (as channel segment) last 8 chars of public key
    S = {SELF}, i.e. set containing own player key & nothing else,
    I = [SELF,null,null...], i.e. initial player list with self as player #1 and no other players,
    R = {G.rootNonterminal}.

In "edit":
On clicking "Start game",
 let C = new unique ID from server,
 if G is single-player,
   render tree R,
   goto "play(C,H,G,I,R)",
  otherwise,
   broadcast Message(C,H,I,R) on channel "join/H/C/SELF",
   subscribe to channel "game/H/C",
   goto "start-wait(C,H,G,I,R)".
On clicking "Join game",
 subscribe to channel "join",
 goto "join".
On clicking "Test game",
 goto "play(C,H,G,I,R)".

In "join":
On receipt of Message(C,H,P,T):
 add (C=>(C,H,P,T,G.name)) to selectable game list.
On selecting game (C=>(C,H,P,T,G.name)) from the game list:
 let P' be P with self written into next available player role,
 broadcast Message(C,H,P',T) on channel "game/H/C/join/ROLE1ID/ROLE2ID/.../SELF",
 unsubscribe from channel "join",
 subscribe to channels "game/H/C/play", "join/H/C", "quit/H/C", and "grammar/H",
 goto "join-wait(C,H,null,P',T)".
On quitting, receiving Quit(C), or editing the grammar,
 broadcast Quit(C) on channel "quit/H/C/~ROLE/SELF",
 unsubscribe from all channels,
 goto "edit".

In "start-wait(C,H,G,P0,T)":
Periodically rebroadcast Message(C,H,P0,T) on "join/H/C/P0".
On receipt of Message(C,H,P,T),
 where P0 \subseteq P:
 if P not fully signed by self,
  sign Message(C,H,P,T) and broadcast on channel "join/H/C/P";
 if P has all players,
    render initial tree T,
    goto "play(C,H,G,P,T)".
  otherwise (still need more players or player1 signature),
   goto "start-wait(C,H,G,P,T)".
On receipt of GrammarRequest(C,H),
 broadcast GrammarResponse(G) on channel "grammar/H/C".
On quitting, receiving Quit(C), or editing the grammar,
 broadcast Quit(C) on channel "quit/H/C/~1/SELF",
 unsubscribe from all channels,
 goto "edit".

In "join-wait(C,H,G0,P0,T0)":
On receipt of GrammarResponse(G),
 verify that md5hash(G) = H,
 unsubscribe from "grammar/H",
 goto "join-wait(C,H,G,P0,T0)".
On receipt of Message(C,H,P,T),
 where P is fully signed by P[1]:
 if P conflicts with P0,
    unsubscribe from all channels,
    subscribe to channel "join",
    goto "join".
 if P has all players,
    if G0 != null, then render initial tree T,
     otherwise broadcast GrammarRequest(H) on channel "game/H/C/request";
    goto "play(C,H,G0,P,T)".
  otherwise (still need more players),
   goto "join-wait(C,H,G0,P,T)".
On quitting, receiving Quit(C), or editing the grammar,
 broadcast Quit(C) on channel "quit/H/C/~ROLE/SELF",
 unsubscribe from all channels,
 goto "edit".

In "play(C,H,G0,P,T0)":
On receipt of GrammarResponse(G),
 verify that md5hash(G) = H,
 render tree T0,
 unsubscribe from "grammar/H",
 goto "play(C,H,G,P,T0)".
On receipt of Message(C,H,P,T),
 where T0 is consistent with T:
 let T' = union(T0,T),
 if T' != T0,
  if G0 != null, then render tree T',
  otherwise broadcast GrammarRequest(H) on channel "game/H/C/request";
 goto "play(C,H,G0,P,T')".
On receipt of GrammarRequest(C),
 broadcast GrammarResponse(G) on channel "grammar/H/C".
On expanding T0->T at node N,
  render tree T,
  broadcast Message(C,H,P,T) on channel "game/H/C/play/P/~SELF/N",
  goto "play(C,H,G0,P,T)".
On quitting, receiving Quit(C), or editing the grammar,
 broadcast Quit(C) on channel "quit/H/C/~ROLE/SELF",
 unsubscribe from all channels,
 goto "edit".




Core engine enhancements:
 Compact JSON representation of parse tree
 Easily-deduced DIV identifier consisting of path to node & choices/sibling positions all along the way; includes parent ID
   e.g. { name:"start", type:"nonterm", choice:3,
          child: [ null, { name:"opening", type:"nonterm", choice:2,
                            child: [ null, null, null, { name:"salutation", type:"nonterm" } ... ] } ...] }
   yields  "@start/c3/s2/@opening/c2/s4/@salutation"
    ...which can be used to quickly locate the node using JQuery
 Click, which triggers code for expanding tree, also broadcasts message (yielding a promise)
   Text default color is bright-red (unless number of players = 1, in which case it's black)
    Visual feedback when promise fulfilled: text fades from bright-red to somewhat-red
 Receiving nodes on channels gives visual feedback:
   Visual feedback when node received in peer message: text fades to faintly-red
   Visual feedback when node received in message from player 1: text fades to black
 Extend turn-attributed grammar language to flag nonterminal ownership:
    player1, player2, ..., playerN,
    samePlayer, nextPlayer, previousPlayer
  Add new "Player Number" to nonterminal editor (incl. same, next, previous)
 N player score variables (evenly spaced along one line)
 LetterWriter language/model extensions:
  "players N"
  player prefix to rule ("#1", "#2", "#next", "#previous", "#same" (default))
  "$#x" expands to "$x".(currentPlayerNumber)
  "score $score" implies $score1,$score2...$scoreN


The first implementation doesn't need hashes, encryption or signatures;
"signing" can be a single (forgeable) bit.
Proper crypto can be added using this library:
http://openpgpjs.org/
