Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (gamefile publication, negotiation, play) into a pub-sub model:
Message(C,H,P,T):
 Does anyone want to play a choose-your-own Adventure game with channel parameter C (which serves as a game ID)
 using the multiplayer turn-attributed grammar G which has MD5 hash H,
  with [possibly incomplete] player list P
   (a vector, where the n'th entry is null or (playerPublicKey + signature of (C,H) + optional P[1] signature))
  starting from rooted parse subtree T?
 If so, and
   your augmented player-lists and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,H,P',T').
 Some subset of the player list is signed by P[1], the first player (must be all if message originates from P[1]).
 Each internal node of T is signed (cryptographically) by the player who expanded that node.

{ channel: C,
  grammar: { name: NAME, roles: ROLES, hash: LETTERWRITER_GRAMMAR_HASH, text: LETTERWRITER_GRAMMAR_TEXT },  // or grammar:null for GrammarRequest
  player: [ { id: USERID_OF_PLAYER1, key: PUBLICKEY_OF_PLAYER1, keyid: ID_OF_PUBLICKEY_OF_PLAYER1, ack: PLAYER1_SIGNATURE_OF_CH },
  	    { id: USERID_OF_PLAYER2, key: PUBLICKEY_OF_PLAYER2, keyid: ID_OF_PUBLICKEY_OF_PLAYER2, sig: PLAYER2_SIGNATURE_OF_"join~ACK1", ack: PLAYER1_SIGNATURE_OF_"ack~SIG2" },
  	    { id: USERID_OF_PLAYER3, key: PUBLICKEY_OF_PLAYER3, keyid: ID_OF_PUBLICKEY_OF_PLAYER3, sig: PLAYER3_SIGNATURE_OF_"join~ACK2", ack: PLAYER1_SIGNATURE_OF_"ack~SIG3" } ],  // last ack is "ACKN"
  tree: { name:"start", type:"nonterm", owner:1, choice:3, sig:PLAYER1_SIGNATURE_OF_"play~ACKN~start/3",
          child: [ null, { name:"opening", type:"nonterm", owner:2, choice:2, sig:PLAYER2_SIGNATURE_OF_"play~ACKN~start/3/2/opening/2",
                           child: [ null, null, null, { name:"salutation", type:"nonterm", owner:3 } ... ] } ...] } }

  	      

GrammarRequest(H).  // a Message containing only hashgram:H
GrammarResponse(G).  // a Message containing only hashgram:H and grammar:G
Quit(C).  // a Message with { channel: C, hashgram: H, quit: { role: N, sig: PLAYERN_SIGNATURE_OF_"quit~SIGN" } }


Channels:
invite/H/C/ROLE1ID/ROLE2ID/ROLE3ID...
apply/H/C/ROLE1ID/ROLE2ID/.../NEWROLEID
request/H/C
grammar/H/C
play/H/C/ROLE1ID/ROLE2ID/.../ROLENID/~ROLE/@nonterm/cCHOICE/sSIBLING/@nonterm/cCHOICE/sSIBLING...
quit/H/C/~ROLE/ID



Let
 SELF = crypto identifier, e.g. public key, or (as channel segment) last 8 chars of public key
    S = {SELF}, i.e. set containing own player key & nothing else,
    I = [SELF,null,null...], i.e. initial player list with self as player #1 and no other players,
    R = {G.rootNonterminal}.

"edit":
Present "Start game", "Join game", "Test game".

On clicking "Start game",
 let C = new unique ID from server,
 if G is single-player,
    RenderTree(null,R);
  otherwise,
   broadcast Message(C,H,I,R) on channel "invite/H/C/SELF",
   activate
    InvitationPublisher(I),
    ApplicationListener on "apply/H/C/SELF",
    RequestListener on "request/H/C",
    QuitListener on "quit/H/C/**".

On clicking "Join game",
 goto "join".

"join":
 present empty game list,
 activate InvitationListener on "invite/**".

On clicking "Test game",
 turn on test mode (solo play, no roles, no pub/sub);
 RenderTree(null,R).

InvitationListener: Channel "invite" Message(C,H,P,T)
 add (C=>(C,H,P,T,G.name)) to selectable game list (make unselectable if full).

On selecting game (C=>(C,H,P,T,G.name)) from the game list,
 let P' be P with self written into next available player role,
 broadcast Message(C,H,P',T) on channel "apply/H/C/ROLE1ID/ROLE2ID/.../SELF",
 deactivate InvitationListener,
 set G0 = null,
 set T0 = null,
 activate
  ConflictListener(P') on "play/H/C/P/**",
  GameListener on "play/H/C/P'/**".

QuitListener on "quit/H/C":
On quitting, receiving Quit(C) on "quit/H/C", or editing the grammar,
 deactivate all listeners,
 broadcast Quit(C) on channel "quit/H/C/~ROLE/SELF",
 goto "edit".

InvitationPublisher(P0):
Periodically rebroadcast Message(C,H,P0,T) on channel "invite/H/C/P0".

ApplicationListener: Channel "apply/H/C/P0" Message(C,H,P,T)
 where P0 \subset P:
  broadcast Message(C,H,P,T) on channels "invite/H/C/P", "play/H/C/P",
  deactivate ApplicationListener, InvitationPublisher,
 if P has all players,
   RenderTree(null,T);
  otherwise,
   activate
    InvitationPublisher(P),
    ApplicationListener on "apply/H/C/P".

RequestListener: Channel "request/H/C" GrammarRequest(C,H)
 broadcast GrammarResponse(G) on channel "grammar/H/C".

GrammarListener: Channel "grammar/H" GrammarResponse(G)
 verify that md5hash(G) = H,
 deactivate GrammarListener,
 set G0 = G,
 if T0 != null,
  RenderTree(null,T0).

ConflictListener(P0): Channel "play/H/C/[all-but-last-of-P0]" Message(C,H,P,T),
 where P is fully signed by P[1]:
 if P conflicts with P0,
    deactivate all listeners,
    activate InvitationListener on "invite/**",
    goto "join".

GameListener: Channel "play/H/C/P0" Message(C,H,P,T),
 deactivate ConflictListener, GameListener,
 if P has all players,
    activate
     QuitListener on "quit/H/C/**",
     GrammarListener on "grammar/H/*".
  otherwise (still need more players),
   activate GameListener on "play/H/C/P/**".

MoveListener[NODE]: Channel "play/H/C/P/~OWNER/NODE" Message(C,H,P,T)
 deactivate MoveListener[NODE],
 RenderTree(T0,T).

On expanding T0->T at node N,
  RenderTree(T0,T);
  broadcast Message(C,H,P,T) on channel "play/H/C/P/~SELF/N",

RenderTree(T0,T):
 while T contains choices not in T0, expand a tip nonterminal in T0, as per T;
 foreach foreign tip LEAF in T0, activate MoveListener[LEAF] on "play/H/C/P/~OWNER/LEAF/**".




Core engine enhancements:
 At occluded siblings of "pause" nodes, postpone computer move until node becomes visible
 Allow Boolean comparison expressions in ParamFunc's
 Move letter.html JavaScript code into LetterWriter.Navigator
  Add code to present main menu ("Start", "Join", "Test") and selectable game list
 Compact JSON representation of parse tree
 Easily-deduced DIV identifier consisting of path to node & choices/sibling positions all along the way; includes parent ID
   e.g. { name:"start", type:"nonterm", choice:3,
          child: [ null, { name:"opening", type:"nonterm", choice:2,
                            child: [ null, null, null, { name:"salutation", type:"nonterm" } ... ] } ...] }
   yields  "@start/c3/s2/@opening/c2/s4/@salutation"
    ...which can be used to quickly locate the node using JQuery
 Click, which triggers code for expanding tree, also broadcasts message (yielding a promise)
   Text default color is bright-red (unless number of players = 1, in which case it's black)
    Visual feedback when promise fulfilled: text fades from bright-red to somewhat-red
 Receiving nodes on channels gives visual feedback:
   Visual feedback when node received in peer message: text fades to faintly-red
   Visual feedback when node received in message from player 1: text fades to black
 Extend turn-attributed grammar language to flag nonterminal ownership:
    player1, player2, ..., playerN,
    samePlayer, nextPlayer, previousPlayer
  Add new "Player Number" to nonterminal editor (incl. same, next, previous)
 N player score variables (evenly spaced along one line)
 LetterWriter language/model extensions:
  "players N"
  player prefix to rule ("#1", "#2", "#next", "#previous", "#same" (default))
  "$#x" expands to "$x".(currentPlayerNumber)
  "score $score" implies $score1,$score2...$scoreN


The first implementation doesn't need hashes, encryption or signatures;
"signing" can be a single (forgeable) bit.
Proper crypto can be added using this library:
http://openpgpjs.org/
