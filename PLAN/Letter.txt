Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (gamefile publication, negotiation, play) into a pub-sub model:
Message(C,H,P,T):
 Does anyone want to play a choose-your-own Adventure game with channel parameter C (which serves as a game ID)
 using the multiplayer turn-attributed grammar G which has MD5 hash H,
  with [possibly incomplete] player list P
   (a vector, where the n'th entry is null or (playerPublicKey + signature of (C,H) + optional P[1] signature))
  starting from rooted parse subtree T?
 If so, and
   your augmented player-lists and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,H,P',T').
 Some subset of the player list is signed by P[1], the first player (must be all if message originates from P[1]).
 Each internal node of T is signed (cryptographically) by the player who expanded that node.
[if P is incomplete for G, rebroadcast on channel 'join/G.name' as well as C, where G.name is the name of the grammar]
[if G.private==true, then (T,Q) parameters of message are encrypted so that only members of P can read.]

GrammarRequest(H).
GrammarResponse(G).


Channels:
join
join/NAME
join/NAME/C
grammar
grammar/H
grammar/H/C
game
game/NAME
game/NAME/C
game/NAME/C/add
game/NAME/C/request
game/NAME/C/play


Client has five states: "edit", "join", "start-wait(H,P,T)", "join-wait(H,G,P,T)", and "play(H,G,P,T)".
Let
 S = {self}, i.e. set containing own player key & nothing else,
 I = [self,null,null...], i.e. initial player list with self as player #1 and no other players,
 R = {G.rootNonterminal}.

In "edit":
On clicking "Start game",
 let C = new unique ID from server,
 broadcast Message(C,H,I,R) on channel "join/G.name/C",
 if G is single-player,
   goto "play(H,G,I,R)",
  otherwise,
   subscribe to channel "game/G.name/C",
   goto "start-wait(H,I,R)".
On clicking "Join game",
 subscribe to channel "join",
 goto "join".
On clicking "Test game",
 goto "play(H,G,I,R)".

In "join":
On receipt of Message(C,H,P,T):
 add (C=>(H,P,T,G.name)) to selectable game list.
On selecting game (C=>(H,P,T,G.name)) from the game list:
 let P' be P with self written into next available player role,
 broadcast Message(C,H,P',T) on channel "game/G.name/C/add",
 unsubscribe from channel "join",
 subscribe to channels "game/G.name/C/play", "join/G.name/C" and "grammar/H",
 goto "join-wait(H,null,P',T)".
On quitting or editing the grammar,
 unsubscribe from all channels,
 goto "edit".

In "start-wait(H,P0,T)":
Periodically rebroadcast Message(C,H,P0,T) on "join/G.name/C".
On receipt of Message(C,H,P,T),
 where P0 \subseteq P:
 if P not fully signed by self,
  sign Message(C,H,P,T) and broadcast on channel "join/G.name/C";
 if P has all players,
    render initial tree T,
    goto "play(H,G,P,T)".
  otherwise (still need more players or player1 signature),
   goto "start-wait(H,P,T)".
On receipt of GrammarRequest(H),
 broadcast GrammarResponse(G) on channel "grammar/H/C".
On quitting or editing the grammar,
 unsubscribe from all channels,
 goto "edit".

In "join-wait(H,G0,P0,T0)":
On receipt of GrammarResponse(G),
 verify that md5hash(G) = H,
 unsubscribe from "grammar/H",
 goto "join-wait(H,G,P0,T0)".
On receipt of Message(C,H,P,T),
 where P is fully signed by P[1]:
 if P conflicts with P0,
    unsubscribe from all channels,
    subscribe to channel "join",
    goto "join".
 if P has all players,
    if G0 != null, then render initial tree T,
     otherwise broadcast GrammarRequest(H) on channel "game/G.name/C/request";
    unsubscribe from channel "join/G.name/C",
    goto "play(H,G0,P,T)".
  otherwise (still need more players),
   goto "join-wait(H,G0,P,T)".
On quitting or editing the grammar,
 unsubscribe from all channels,
 goto "edit".

In "play(H,G0,P,T0)":
On receipt of GrammarResponse(G),
 verify that md5hash(G) = H,
 render tree T0,
 unsubscribe from "grammar/H",
 goto "play(H,G,P,T0)".
On receipt of Message(C,H,P,T),
 where T0 is consistent with T:
 let T' = union(T0,T),
 if T' != T0,
  if G0 != null, then render tree T',
  otherwise broadcast GrammarRequest(H) on channel "game/G.name/C/request";
 goto "play(H,G0,P,T')".
On receipt of GrammarRequest(H),
 broadcast GrammarResponse(G) on channel "grammar/H/C".
On expanding T0->T,
  render tree T,
  broadcast Message(C,H,P,T) on channel "game/G.name/C/play",
  goto "play(H,G0,P,T)".
On quitting or editing the grammar,
 unsubscribe from all channels,
 goto "edit".




Core engine enhancements:
 Compact JSON representation of parse tree
  Unique node identifier consisting of path to node & choices/sibling positions all along the way; includes parent ID
   e.g. "@start/c3/s2/@opening/c2/s4/@salutation"
 Click, which triggers code for expanding tree, also broadcasts message (yielding a promise)
   Text default color is bright-red (unless number of players = 1, in which case it's black)
    Visual feedback when promise fulfilled: text fades from bright-red to somewhat-red
 Receiving nodes on channels gives visual feedback:
   Visual feedback when node received in peer message: text fades to faintly-red
   Visual feedback when node received in message from player 1: text fades to black
 Extend turn-attributed grammar language to flag nonterminals as being player1, player2, ..., playerN, or nextPlayer (the player whose player number is one higher than the parent, modulo N)
  Add new "Player Number" to nonterminal editor
 N player score variables (evenly spaced along one line)
 LetterWriter language/model extensions:
  "players N"
  player prefix to rule ("#1", "#2", or nothing for "next")
  "$x#" expands to "$x".(currentPlayerNumber)
  "score $score" implies $score1,$score2...$scoreN


The first implementation doesn't need hashes, encryption or signatures;
"signing" can be a single (forgeable) bit.
Proper crypto can be added using this library:
http://openpgpjs.org/
