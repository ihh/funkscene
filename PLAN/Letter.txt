Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (REST, negotiation, play) into a single monoidal crypto-question:
Message(C,HG,T,P,Q):
 Does anyone want to play a choose-your-own Adventure game using the multiplayer turn-attributed grammar G which has MD5 hash HG,
  with [possibly incomplete] player list P,
   and rooted parse subtree T?
 If so, and
   your augmented player-list and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,HG,T',P',Q').
 Signed (cryptographically), some set of players Q, where Q \subseteq P.
[optionally includes G, or request for G]
[if P is incomplete for HG, rebroadcast on channel 'join/G.name' as well as C, where G.name is the name of the grammar]
[if G.private==true, then (T,Q) encrypted for members of P]

http://openpgpjs.org/


Core engine enhancements:
 Compact JSON representation of parse tree
 Extend turn-attributed grammar language to flag nonterminals as being player1, player2, or nextPlayer (the latter means "opposite of parent")
  Six options on Player dropdown menu: Player1, Computer1, Player2, Computer2, NextPlayer, NextComputer
 Two player score variables (Player 1 score left-aligned, Player 2 score right-aligned)
 Language extensions: "players 1" or "players 2", "score $score1 $score2", player prefix to rule ("#1", "#2", or nothing for "next"), "$x#" expands to "$x".(currentPlayerNumber)
