Multiplayer

http://faye.jcoglan.com/node.html
http://faye.jcoglan.com/browser.html
http://faye.jcoglan.com/browser/subscribing.html
http://faye.jcoglan.com/browser/publishing.html


Boil all of it (gamefile publication, negotiation, play) into a pub-sub model:
Message(C,H,P,T):
 Does anyone want to play a choose-your-own Adventure game with channel parameter C (which serves as a game ID)
 using the multiplayer turn-attributed grammar G which has MD5 hash H,
  with [possibly incomplete] player list P
   (a vector, where the n'th entry is null or (playerPublicKey + signature of (C,H) + optional P[1] signature))
  starting from rooted parse subtree T?
 If so, and
   your augmented player-lists and/or parse tree are (P',T'),
    where P \subseteq P' and T \subseteq T',
   then respond on channel C with Message(C,H,P',T').
 Some subset of the player list is signed by P[1], the first player (must be all if message originates from P[1]).
 Each internal node of T is signed (cryptographically) by the player who expanded that node.

{ channel: C,
  hashgram: H,
  grammar: G,  // or grammar:null for GrammarRequest
  player: [ { uid: USERID_OF_PLAYER1, key: PUBLICKEY_OF_PLAYER1, keyid: ID_OF_PUBLICKEY_OF_PLAYER1, ack: PLAYER1_SIGNATURE_OF_CH },
  	    { uid: USERID_OF_PLAYER2, key: PUBLICKEY_OF_PLAYER2, keyid: ID_OF_PUBLICKEY_OF_PLAYER2, sig: PLAYER2_SIGNATURE_OF_"join~ACK1", ack: PLAYER1_SIGNATURE_OF_"ack~SIG2" },
  	    { uid: USERID_OF_PLAYER3, key: PUBLICKEY_OF_PLAYER3, keyid: ID_OF_PUBLICKEY_OF_PLAYER3, sig: PLAYER3_SIGNATURE_OF_"join~ACK2", ack: PLAYER1_SIGNATURE_OF_"ack~SIG3" } ],  // last ack is "ACKN"
  tree: { name:"start", type:"nonterm", owner:1, choice:3, sig:PLAYER1_SIGNATURE_OF_"play~ACKN~start/3",
          child: [ null, { name:"opening", type:"nonterm", owner:2, choice:2, sig:PLAYER2_SIGNATURE_OF_"play~ACKN~start/3/2/opening/2",
                           child: [ null, null, null, { name:"salutation", type:"nonterm", owner:3 } ... ] } ...] } }

  	      

GrammarRequest(H).  // a Message containing only hashgram:H
GrammarResponse(G).  // a Message containing only hashgram:H and grammar:G
Quit(C).  // a Message with { quit: { role: N, sig: PLAYERN_SIGNATURE_OF_"quit~SIGN" } }


Channels:
invite
invite/H/C/ROLE1ID/ROLE2ID/ROLE3ID...
quit/H/C/~ROLE/ID
grammar
grammar/H
grammar/H/C
game
game/H
game/H/C
game/H/C/apply/ROLE1ID/ROLE2ID/.../NEWROLEID
game/H/C/request
game/H/C/play/ROLE1ID/ROLE2ID/.../ROLENID/~ROLE/@nonterm/cCHOICE/sSIBLING/@nonterm/cCHOICE/sSIBLING...


Let
 SELF = crypto identifier, e.g. public key, or (as channel segment) last 8 chars of public key
    S = {SELF}, i.e. set containing own player key & nothing else,
    I = [SELF,null,null...], i.e. initial player list with self as player #1 and no other players,
    R = {G.rootNonterminal}.

"edit":
Present "Start game", "Join game", "Test game".

On clicking "Start game",
 let C = new unique ID from server,
 if G is single-player,
   render tree R,
  otherwise,
   broadcast Message(C,H,I,R) on channel "invite/H/C/SELF",
   activate ApplicationListener, RequestListener, QuitListener.

On clicking "Join game",
"join":
 present empty game list,
 activate InvitationListener on "invite".

On clicking "Test game",
 render tree R, with test mode turned on (solo mode, no pub/sub).

InvitationListener: Channel "invite" Message(C,H,P,T)
 add (C=>(C,H,P,T,G.name)) to selectable game list.

On selecting game (C=>(C,H,P,T,G.name)) from the game list,
 let P' be P with self written into next available player role,
 broadcast Message(C,H,P',T) on channel "game/H/C/apply/ROLE1ID/ROLE2ID/.../SELF",
 deactivate InvitationListener,
 activate
  ConflictListener on "game/H/C/play/P",
  QuitListener on "quit/H/C",
  GrammarListener on "grammar/H".

QuitListener on "quit/H/C":
On quitting, receiving Quit(C) on "quit/H/C", or editing the grammar,
 broadcast Quit(C) on channel "quit/H/C/~ROLE/SELF",
 unsubscribe from all channels,
 goto "edit".

InvitationPublisher:
Periodically rebroadcast Message(C,H,P0,T) on channel "invite/H/C/P0".

ApplicationListener: Channel "game/H/C/apply" Message(C,H,P,T)
 where P0 \subset P:
  sign Message(C,H,P,T) and broadcast on channels "invite/H/C/P", "game/H/C/play/P";
 if P has all players,
    render initial tree T.

RequestListener: Channel "game/H/C/request" GrammarRequest(C,H)
 broadcast GrammarResponse(G) on channel "grammar/H/C".

GrammarListener: Channel "grammar/H" GrammarResponse(G)
 verify that md5hash(G) = H,
 deactivate GrammarListener,
 goto "join-wait(C,H,G,P0,T0)".

ConflictListener: Channel "game/H/C/play/[all-but-last-of-P0]" Message(C,H,P,T),
 where P is fully signed by P[1]:
 if P conflicts with P0,
    unsubscribe from all channels,
    activate InvitationListener on "invite",
    goto "join".
 if P has all players,
    if G0 != null, then render initial tree T,
     otherwise broadcast GrammarRequest(H) on channel "game/H/C/request";
    goto "play(C,H,G0,P,T)".
  otherwise (still need more players),
   goto "join-wait(C,H,G0,P,T)".

MoveListener: Channel "game/H/C/play/P/~OWNER/NODE" Message(C,H,P,T)
 expand T0->T from NODE, activating MoveListeners at unowned tips

On expanding T0->T at node N,
  render tree T, activating MoveListeners at unowned tips
  broadcast Message(C,H,P,T) on channel "game/H/C/play/P/~SELF/N",




Core engine enhancements:
 Compact JSON representation of parse tree
 Easily-deduced DIV identifier consisting of path to node & choices/sibling positions all along the way; includes parent ID
   e.g. { name:"start", type:"nonterm", choice:3,
          child: [ null, { name:"opening", type:"nonterm", choice:2,
                            child: [ null, null, null, { name:"salutation", type:"nonterm" } ... ] } ...] }
   yields  "@start/c3/s2/@opening/c2/s4/@salutation"
    ...which can be used to quickly locate the node using JQuery
 Click, which triggers code for expanding tree, also broadcasts message (yielding a promise)
   Text default color is bright-red (unless number of players = 1, in which case it's black)
    Visual feedback when promise fulfilled: text fades from bright-red to somewhat-red
 Receiving nodes on channels gives visual feedback:
   Visual feedback when node received in peer message: text fades to faintly-red
   Visual feedback when node received in message from player 1: text fades to black
 Extend turn-attributed grammar language to flag nonterminal ownership:
    player1, player2, ..., playerN,
    samePlayer, nextPlayer, previousPlayer
  Add new "Player Number" to nonterminal editor (incl. same, next, previous)
 N player score variables (evenly spaced along one line)
 LetterWriter language/model extensions:
  "players N"
  player prefix to rule ("#1", "#2", "#next", "#previous", "#same" (default))
  "$#x" expands to "$x".(currentPlayerNumber)
  "score $score" implies $score1,$score2...$scoreN


The first implementation doesn't need hashes, encryption or signatures;
"signing" can be a single (forgeable) bit.
Proper crypto can be added using this library:
http://openpgpjs.org/
