\documentclass{acm_proc_article-sp}
\bibliographystyle{unsrt}

\begin{document}

\title{A Web-Based Editor for Multiplayer Choice Games}
\numberofauthors{1}
\author{
% 1st. author
\alignauthor
Ian Holmes\\
       \affaddr{Department of Bioengineering}\\
       \affaddr{University of California}\\
       \affaddr{California, Berkeley}\\
       \email{ihh@berkeley.edu}
}
\date{30 November, 2013}

\maketitle
\begin{abstract}
Multiplayer choose-your-own stories based on context-free grammars.
Fully self-contained editor (with map overview), parse tree debugger, network player.
\end{abstract}

% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]


\section{Introduction}

What is a CFG?
How does a CFG subsume the state machine of an FSA?
How is a CFG like a pushdown automaton?
How is a CFG like CYOA with GOSUB?
How is a CFG like CYOA with continuation-passing style?
How does an SCFG subsume a CFG? (Turing wanted true randomness in all computers...)

\cite{DBLP:conf/icalp/EtessamiWY08}

Grammars as metaphysical systems
\cite{SanskritSutras}
\cite{Priscian}

Grammars as tools of social unification and control
\cite{AcademieFrancaise}
\cite{RobertLowth}

Formal grammars and commonalities of human language
\cite{Chomsky}

Grammars and compilers
\cite{AhoLamSethiUllmanCompilersDragonBook}

Games and scripts
\cite{EricBerneGamesPeoplePlay,EricBerneWhatDoYouSayAfterYouSayHello}

Grammars in graphics and games
\cite{LSystems}
\cite{Sims3}

Grammars in DNA sequence analysis
\cite{Durbin98}

Choose-your-own story engines and interactive authoring environments
\cite{Twine,InkleWriter,ChoiceScript,Undum,RenPy}


\section{Design}

\subsection{Game language}

At the core of LetterWriter is LetterLanguage,
a declarative, domain-specific language for specifying an attributed context-free gramamr.

The core element in this grammar, syntactically and semantically, is the {\em transformation rule}.
\begin{verbatim}
 @scene => { hint => expansion }
\end{verbatim}
In this, {\tt \@scene} is a label denoting the current scene;
{\tt hint} is text presented to the player as a choice;
and {\tt expansion} is text that will be generated if the player makes this choice
(which can include further scene labels).

A block of transformation rules represents a list of choices:
\begin{verbatim}
 @scene => { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}
Any number of ({\tt hint},{\tt expansion}) tuples are allowed.
Whitespace can be ignored (although it is preserved in rendered text),
and the {\tt hint=>} can be omitted as well.
There is also an optional longer form
\begin{verbatim}
 @scene => [ preamble | placeholder | prompt ]
           { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}

Here, {\tt preamble} is text describing the scene;
{\tt placeholder} is text temporarily displayed at the bottom of the scene (before the list of choices),
and deleted when an expansion is selected;
and {\tt prompt} is text, also transiently displayed, that is associated with the list of choices.
(Typically the prompt takes the form of a question addressed directly to the player.)

As with other parts of the syntax beyond the core idea of a context-free transformation rule,
the preamble and/or placeholder can be omitted.

Here is an actual working example \cite{ChoiceOfGamesBlog}:
\begin{verbatim}
 @unrest =>
[ The peasants are revolting. 
  | _So tedious..._ 
  | What will you do? ] 
{ Feed them.
   => You cast grain from the battlements.
      @peace
| Play some music.
   => No lute can drown their hungry groans.
      @revolt }
\end{verbatim}

The words ``{\em So tedious...}'' will disappear when a selection is made; being wrapped in underscores, they will also appear in italics, as a result of the Markdown-like macro transformation.
The prompt ``What will you do?'' will also disappear when a selection made.
(In multiplayer mode, the prompt is only shown to the active player.)



In the terminology of formal grammar theory: the scene label {\tt \@scene} is a {\em nonterminal symbol},
whereas other rendered text is composed of {\em terminal symbols} (ASCII characters).
Nonterminal symbols denote points in the text (scenes) where further expansion is possible;
terminal symbols denote static endpoints of the text.
The preamble, placeholder, prompt and hint are {\em attributes}
added to make the grammar formalism a little more friendly to writing interactive stories.

All nonterminal symbols begin with {\tt @}.
Special characters such as {\tt \$@[]\{\}} can be escaped with a backslash if required in the text.
Quotation marks and other common punctuation are not special characters and can be used directly, as can HTML tags.
Some syntactic sugar for HTML tags (e.g. flanking underscores for italics) is borrowed from Markdown \cite{Markdown}.

Starting from an initial designated nonterminal (named {\tt @start} by default),
iterated application of these rules generates a {\em parse tree},
with nonterminal symbols at internal nodes and terminal symbols at the tips.
The final text can be read off from the terminals at the leaf nodes.

The sequence of terminals is post-processed before being rendered,
so the terminals themselves do not necessarily correspond exactly to what is shown on screen.
Specifically, the terminal nodes at the leaves of the parse tree represent a {\em program text},
which can contain embedded commands (such as variable substitutions)
that are then interpreted to (deterministically) compute the {\em story text} presented to the player.
As noted above, a Markdown-like macro expansion is further applied to the generated story text,
for quick HTML styling \cite{Markdown}.

Extra keywords are available; for example, to specify that some variables are directly controlled by the player,
(using sliders), or to delineate a variable as the score.
Other keywords can specify the game title, or control the behavior of the ``undo'' button.

Not all transformation rules need be presented to the player at every opportunity.
The author can flag individual rules to be hidden from view some fixed number of times
before first being shown, or limited to some finite number of uses.
Various modifier keywords can be associated with nonterminals to indicate this in the game source file.

More computationally expressive logic for controlling story flow is available via the use of computer players.
For nonterminals that are flagged as belonging to the computer player,
rules are normally played at random,
but this behavior can be manipulated by the author to
assign different probabilistic weights to the rules
(and these weights can also be boolean logic expressions, allowing for more sophisticated control of flow).
The player can also ``steer'' the computer player by manipulating probabilistic weight parameters directly,
by means of slider controls in the HTML page.

\subsection{Editor}

FIGURE

At the most basic level, the editor includes a textbox for direct editing of game source code.
Beyond this, a number of User Interface (UI)
elements are presented together as a basic Integrated Development Environment (IDE).

The main element is a drag-and-drop sortable list of nonterminal editing panes.
Each nonterminal pane contains a drag-and-drop-sortable list of transformation rules,
together with UI elements for modifying rule behavior (e.g. the number of times
a rule can be used by, or should be hidden from, the player).
An overview summarizes orphan nonterminals (never generated by any rules),
bare nonterminals (no text), and empty rules (loose ends).
Hyperlinks are provided for quick navigation to incoming/outgoing nonterminals,
and also to the map view.

Another drag-and-drop sortable list specifies the parameters that the player
can set directly via slider controls.
A few properties of the grammar (such as its title) can be directly edited.

\subsection{Map}

FIGURE

The map, rendered using a third-party graph visualization library,
shows the overall structure of the game.
Nodes represent nonterminals (arranged in a circular layout).
Edges $a \to b$ imply the existence of at least one rule $a \to \ldots b \ldots$
with $a$ on the left-hand side and $b$ on the right.

Nodes are colored to represent some useful information
(e.g. whether the corresponding nonterminal is human- or player-controlled,
whether it is a loose end, and so forth).
The author can mouse-over a node to highlight incoming \& outgoing edges.

\subsection{Parse tree debugger}

FIGURE

The parse tree is visualized using the same graph library as the map.
The type and status of nodes (terminals, expanded/unexpanded nonterminals, expanded/unexpanded computer-controlled nonterminals, parameter references/assignments/inputs) is indicated via size and coloring.
The author can mouseover nodes for more info (e.g. the order and time of expansion).
Clicking on a node navigates to the corresponding nonterminal pane in the editor.

\subsection{Game client}

Rendering of tree with minimal, discreet styling and animation (e.g. fade-in).

``Undo'' button with gradually-increasing recharge time is offered as an optional game mechanic for solo play.

\subsection{Multiplayer operation}

Publish-subscribe model.
Invitation channel.
Play channel: hierarchically-structured channels, one channel for each node of parse tree.
Discreet animations conveying (a) successful publication of rule expansion to server, (b) successful server subscription at a given placeholder, listening for remote player choice.

\section{Discussion}

Structured chat-room?
Scripted interactive date?
Dungeonmaster-player?
Many possibilities...


\subsection{Cryptographic play}

Sketch of crypto-signed play.

Crucial messages can be signed (and counter-signed when received): invitations, applications to join the game, expansions of nodes in the parse tree.
No need for central authority.

\subsection{Optimal strategies}

Strategically optimal algorithms for playing this kind of game are known to exist when the scoring scheme is extremely predictable (e.g. linear in nonterminal usage \cite{DBLP:conf/icalp/EtessamiWY08}).
However, the scoring scheme described here is considerably more flexible, modeling many aspects of context-sensitive grammars as well as CFGs.

The programming language for the computer player does not attempt to model AI in any deep sense:
it is very simple, just offering variables, conditional tests, and the in-built facility for looping and recursion that comes for free with the CFG.

A theoretical extension is to use an ambiguous grammar (multiple parse trees consistent with observed output)
and introduce a computer player that can parse the current output (e.g. using Earley \cite{Stolcke}) and predict future outcomes.

\subsection{Implementation}

JavaScript, SigmaJS, PegJS, JQuery, OpenPGP, Node, Faye.

Early choose-your-own story prototype developed using Scheme.
Prototype of parser-based play developed using Perl.


\subsection{Availability}

{\tt https://github.com/ihh/funkscene}

\section{References}

%Recursive Stochastic Games with Positive Rewards. Etessami, Wojtczak, Yannakakis. Automata, Languages and Programming. Lecture Notes in Computer Science Volume 5125, 2008, pp 711-723

\bibliography{lwpaper}

\balancecolumns
% That's all folks!
\end{document}
