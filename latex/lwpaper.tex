\documentclass{acm_proc_article-sp}
\bibliographystyle{unsrt}

\begin{document}

\title{A Web-Based Editor for Multiplayer Choice Games}
\numberofauthors{1}
\author{
% 1st. author
\alignauthor
Ian Holmes\\
       \affaddr{Department of Bioengineering}\\
       \affaddr{University of California}\\
       \affaddr{California, Berkeley}\\
       \email{ihh@berkeley.edu}
}
\date{30 November, 2013}

\maketitle
\begin{abstract}
Choice-based interactive fiction can be based on context-free grammars.
This paper describes a fully self-contained interactive development environment for such stories,
with a map overview, parse tree debugger, and network client for multiplayer games.
\end{abstract}

% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]


\section{Introduction}

Choice-based interactive fiction came of age in the 1980's:
Choose Your Own Adventure, Fighting Fantasy, and Lone Wolf were well-known imprints.
The genre has seen an early 21st-century resurgence with the advent of writing tools
(from domain-specific languages like ChoiceScript, to interactive editors like Twine)
which have lowered the barriers to game creation and increased the diversity of authorial voices.

A choice-based story can be compared to a flowchart, or a state machine,
or (in the language of grammar theory) a {\em regular grammar}.
The main control-flow construct is the conditional {\tt GOTO} statement
(``{\em if you have the chalice, turn to page 400}'').
The structure of the story is a linear progression of scenes.

In modeling many kinds of text, it is often useful to allow a richer structure.
For example, conversations often make diversions (sometimes multiply nested diversions) before returning to the central topic.
Epic adventures can include side-quests; stories often have epilogues.

This sort of structure can be modeled using a {\em context-free grammar} (CFG).
If a typical choice-based story (with a regular grammar) is akin to a state machine,
 whose main control-flow construct is {\tt GOTO},
then a CFG-based story is like a pushdown automaton (a finite-state machine with a stack)
 which allows not only {\tt GOTO} but also {\tt GOSUB}.

To extend choice-based stories in this way might indicate an excessive fondness for formalism.
However, a well-defined framework provides a robust foundation.
Here, we describe a software system that allows authoring of story CFGs
via an interface inspired by graphical editors like Twine and domain-specific languages like ChoiceScript.
The created games can be played over the web by multiple players in different locations.

One typical advantage of a formal framework is a rich variety of links to other areas of culture.
Grammars have variously served as metaphysical systems\cite{SanskritSutras,Priscian},
tools of social unification and control\cite{AcademieFrancaise,RobertLowth},
and models of natural language\cite{Chomsky}.
They have been used in compiler theory\cite{AhoLamSethiUllmanCompilersDragonBook},
DNA sequence analysis\cite{Durbin98},
computer graphics\cite{LSystems}, and game AI\cite{Sims3}.
There is even a literature on game-theoretic analysis of grammar-based games
\cite{DBLP:conf/icalp/EtessamiWY08}.
The idea of templates and scripts for social interactions has a rich history in popular psychology\cite{EricBerneGamesPeoplePlay,EricBerneWhatDoYouSayAfterYouSayHello}.
All of the above influences offer a source of inspiration for single- and multiplayer game design.

\section{Design}

\subsection{Game language}

At the core of LetterWriter is LetterLanguage,
a declarative, domain-specific language for specifying an attributed CFG.

The core element in this grammar, syntactically and semantically, is the {\em transformation rule}.
\begin{verbatim}
 @scene => { hint => expansion }
\end{verbatim}
In this, {\tt \@scene} is a label denoting the current scene;
{\tt hint} is text presented to the player as a choice;
and {\tt expansion} is text that will be generated if the player makes this choice
(which can include further scene labels).

A block of transformation rules represents a list of choices:
\begin{verbatim}
 @scene => { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}
Any number of ({\tt hint},{\tt expansion}) tuples are allowed.
Whitespace can be ignored (although it is preserved in rendered text),
and the {\tt hint=>} can be omitted as well.
There is also an optional longer form
\begin{verbatim}
 @scene => [ preamble | placeholder | prompt ]
           { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}

Here, {\tt preamble} is text describing the scene;
{\tt placeholder} is text temporarily displayed at the bottom of the scene (before the list of choices),
and deleted when an expansion is selected;
and {\tt prompt} is text, also transiently displayed, that is associated with the list of choices.
(Typically the prompt takes the form of a question addressed directly to the player.)

As with other parts of the syntax beyond the core idea of a context-free transformation rule,
the preamble and/or placeholder can be omitted.

Here is an example:
\begin{verbatim}
 @unrest =>
[ The peasants are revolting. 
  | _So tedious..._ 
  | What will you do? ] 
{ Feed them.
   => You cast grain from the battlements.
      @peace
| Play some music.
   => No lute can drown their hungry groans.
      @revolt }
\end{verbatim}

The words ``{\em So tedious...}'' will disappear when a selection is made; being wrapped in underscores, they will also appear in italics, as a result of the Markdown-like macro transformation.
The prompt ``What will you do?'' will also disappear when a selection made.
(In multiplayer mode, the prompt is only shown to the active player.)



In the terminology of formal grammar theory: the scene label {\tt \@scene} is a {\em nonterminal symbol},
whereas other rendered text is composed of {\em terminal symbols} (ASCII characters).
Nonterminal symbols denote points in the text (scenes) where further expansion is possible;
terminal symbols denote static endpoints of the text.
The preamble, placeholder, prompt and hint are {\em attributes}
added to make the grammar formalism a little more friendly to writing interactive stories.

All nonterminal symbols begin with {\tt @}.
Special characters such as {\tt \$@[]\{\}} can be escaped with a backslash if required in the text.
Quotation marks and other common punctuation are not special characters and can be used directly, as can HTML tags.
Some syntactic sugar for HTML tags (e.g. flanking underscores for italics) is borrowed from Markdown \cite{Markdown}.

Starting from an initial designated nonterminal (named {\tt @start} by default),
iterated application of these rules generates a {\em parse tree},
with nonterminal symbols at internal nodes and terminal symbols at the tips.
The final text can be read off from the terminals at the leaf nodes.

The sequence of terminals is post-processed before being rendered,
so the terminals themselves do not necessarily correspond exactly to what is shown on screen.
Specifically, the terminal nodes at the leaves of the parse tree represent a {\em program text},
which can contain embedded commands (such as variable assignments, inputs, modification, and interpolation)
that are then interpreted to (deterministically) compute the {\em story text} presented to the player.
As noted above, a Markdown-like macro expansion is further applied to the generated story text,
for quick HTML styling \cite{Markdown}.

Extra keywords are available; for example, to specify that some variables are directly controlled by the player,
(using sliders), or to delineate a variable as the score.
Other keywords can specify the game title, or control the behavior of the ``undo'' button.

Not all transformation rules need be presented to the player at every opportunity.
The author can flag individual rules to be hidden from view some fixed number of times
before first being shown, or limited to some finite number of uses.
Various modifier keywords can be associated with nonterminals to indicate this in the game source file.

More computationally expressive logic for controlling story flow is available via the use of computer players.
For nonterminals that are flagged as belonging to the computer player,
rules are normally played at random,
but this behavior can be manipulated by the author to
assign different probabilistic weights to the rules
(and these weights can also be boolean logic expressions, allowing for more sophisticated control of flow).
The player can also ``steer'' the computer player by manipulating probabilistic weight parameters directly,
by means of slider controls in the HTML page.

\subsection{Editor}

FIGURE

At the most basic level, the editor includes a textbox for direct editing of game source code.
Beyond this, a number of User Interface (UI)
elements are presented together as a basic Integrated Development Environment (IDE).

The main element is a drag-and-drop sortable list of nonterminal editing panes.
Each nonterminal pane contains a drag-and-drop-sortable list of transformation rules,
together with UI elements for modifying rule behavior (e.g. the number of times
a rule can be used by, or should be hidden from, the player).
An overview summarizes orphan nonterminals (never generated by any rules),
bare nonterminals (no text), and empty rules (loose ends).
Hyperlinks are provided for quick navigation to incoming/outgoing nonterminals,
and also to the map view.

Another drag-and-drop sortable list specifies the parameters that the player
can set directly via slider controls.
A few properties of the grammar (such as its title) can be directly edited.

\subsection{Map}

FIGURE

The map, rendered using a third-party graph visualization library,
shows the overall structure of the game.
Nodes represent nonterminals (arranged in a circular layout).
Edges $a \to b$ imply the existence of at least one rule $a \to \ldots b \ldots$
with $a$ on the left-hand side and $b$ on the right.

Nodes are colored to represent some useful information
(e.g. whether the corresponding nonterminal is human- or player-controlled,
whether it is a loose end, and so forth).
The author can mouse-over a node to highlight incoming \& outgoing edges.

\subsection{Parse tree debugger}

FIGURE

The parse tree is visualized using the same graph library as the map.
The type and status of nodes (terminals, expanded/unexpanded nonterminals, expanded/unexpanded computer-controlled nonterminals, parameter references/assignments/inputs) is indicated via size and coloring.
The author can mouseover nodes for more info (e.g. the order and time of expansion).
Clicking on a node navigates to the corresponding nonterminal pane in the editor.

\subsection{Game client}

The parse tree is rendered as text after performing variable substitutions.
Discreet and minimal styling is used to present choice lists and animate text
(e.g. an unobtrusive fade-in of newly-rendered text).

An ``undo'' button with gradually-increasing recharge time is offered as an optional game mechanic for solo play.
(The complications of implementing ``undo'' in multiplayer play were eschewed;
 we observe in any case that ``undo'' is rarely a participation-enhancing mechanic for choose-your-own games.)

\subsection{Multiplayer operation}

Multiplayer mode is enabled by increasing the number of {\em roles} in the grammar from its default value of 1.
The number of roles is the same as the number of (human) players.
Each nonterminal node in the parse tree is controlled (i.e. can only be expanded) by a specific and well-defined role;
by default, a node's controlling role is the immediate successor of the parent node's controlling role
(modulo the total number of roles).
Thus, by default, control passes predictably from one player to the next,
although this behavior can be modified by the author (e.g. to indicate that a particular nonterminal
should always be controlled by a given role).
For every human player, there is also a computer player.

Multiplayer mode is implemented using a third-party publish-subscribe (pub-sub) framework.
Games are organized on an invitation channel and then take place on an hierarchically-structured
play channel, with one channel for each node of the parse tree.
Discreet animations convey
 (a) successful publication of rules to the pub-sub server (for locally-controlled node expansions),
 (b) successful subscription of a listener at a particular point in the parse tree (for remotely-controlled nodes).

\section{Discussion}

Grammars are found throughout computer science,
and there are many potential applications of an
integrated system for designing grammars and then using them collaboratively to generate texts over a network.
Such applications range from
serious uses in IT enterprise (e.g. structured chat-rooms for product support),
through traditional game tropes (e.g. dungeonmaster-player conversations),
through new electronic models of social interaction (e.g. scripted interactive dates).

Below, we discuss some theoretical extensions.

\subsection{Cryptographic play}

Cryptographically-authenticated play would almost completely obviate the need for a server
assuming a distributed pub-sub framework is practical).
A cryptographic extension of the basic pub-sub model is straightforward.
Crucial messages must be signed (and counter-signed when received):
these include invitations, applications to join the game, and rule expansions.

\subsection{Optimal strategies}

Strategically optimal algorithms for playing this kind of game are known to exist when the scoring scheme is a trivial function of the parse tree (e.g. fixed rewards for using certain nonterminals \cite{DBLP:conf/icalp/EtessamiWY08}).
However, the scoring scheme described here is considerably more flexible, modeling many aspects of context-sensitive grammars as well as CFGs.

The programming language for the computer player does not attempt to model AI in any deep sense:
it is very simple, just offering variables, conditional tests, and the in-built facility for looping and recursion that comes for free with the CFG.

A possible extension is to use an ambiguous grammar (multiple parse trees consistent with observed output)
and introduce a computer player that can parse the current output (e.g. using Earley \cite{Stolcke}) and predict future outcomes.

\subsection{Implementation}

JavaScript, SigmaJS, PegJS, JQuery, OpenPGP, Node, Faye.

Early choose-your-own story prototype developed using Scheme.
Prototype of parser-based play developed using Perl.


\subsection{Availability}

{\tt https://github.com/ihh/funkscene}

\bibliography{lwpaper}

\balancecolumns
% That's all folks!
\end{document}
