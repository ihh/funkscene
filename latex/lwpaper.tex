\documentclass{acm_proc_article-sp}
\bibliographystyle{unsrt}

\begin{document}

\title{A Web-Based Editor for Multiplayer Choice Games}
\numberofauthors{1}
\author{
% 1st. author
\alignauthor
Ian Holmes\\
       \affaddr{Department of Bioengineering}\\
       \affaddr{University of California}\\
       \affaddr{California, Berkeley}\\
       \email{ihh@berkeley.edu}
}
\date{30 November, 2013}

\maketitle
\begin{abstract}
Multiplayer choose-your-own stories based on context-free grammars.
Fully self-contained editor (with map overview), parse tree debugger, network player.
\end{abstract}

% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]


\section{Introduction}

What is a CFG?
How does a CFG subsume the state machine of an FSA?
How is a CFG like a pushdown automaton?
How is a CFG like CYOA with GOSUB?
How is a CFG like CYOA with continuation-passing style?
How does an SCFG subsume a CFG? (Turing wanted true randomness in all computers...)

\cite{DBLP:conf/icalp/EtessamiWY08}

Grammars as metaphysical systems
\cite{SanskritSutras}
\cite{Priscian}

Grammars as tools of social unification and control
\cite{AcademieFrancaise}
\cite{RobertLowth}

Formal grammars and commonalities of human language
\cite{Chomsky}

Grammars and compilers
\cite{AhoLamSethiUllmanCompilersDragonBook}

Games and scripts
\cite{EricBerneGamesPeoplePlay,EricBerneWhatDoYouSayAfterYouSayHello}

Grammars in graphics and games
\cite{LSystems}
\cite{Sims3}

Grammars in DNA sequence analysis
\cite{Durbin98}

Choose-your-own story engines and interactive authoring environments
\cite{Twine,InkleWriter,ChoiceScript,Undum,RenPy}


\section{Design}

\subsection{Game language}

At the core of LetterWriter is LetterLanguage,
a declarative, domain-specific language for specifying an attributed context-free gramamr.

The core element in this grammar, syntactically and semantically, is the {\em transformation rule}.
\begin{verbatim}
 @scene => { hint => expansion }
\end{verbatim}
In this, {\tt \@scene} is a label denoting the current scene;
{\tt hint} is text presented to the player as a choice;
and {\tt expansion} is text that will be generated if the player makes this choice
(which can include further scene labels).

A block of transformation rules represents a list of choices:
\begin{verbatim}
 @scene => { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}
Any number of ({\tt hint},{\tt expansion}) tuples are allowed.
Whitespace can be ignored (although it is preserved in rendered text),
and the {\tt hint=>} can be omitted as well.
There is also an optional longer form
\begin{verbatim}
 @scene => [ preamble | placeholder | prompt ]
           { hint1 => expansion1
           | hint2 => expansion2
           | hint3 => expansion3 }
\end{verbatim}

Here, {\tt preamble} is text describing the scene;
{\tt placeholder} is text temporarily displayed at the bottom of the scene (before the list of choices),
and deleted when an expansion is selected;
and {\tt prompt} is text, also transiently displayed, that is associated with the list of choices.
(Typically the prompt takes the form of a question addressed directly to the player.)

As with other parts of the syntax beyond the core idea of a context-free transformation rule,
the preamble and/or placeholder can be omitted.

Here is an actual working example \cite{ChoiceOfGamesBlog}:
\begin{verbatim}
 @unrest =>
[ The peasants are revolting. 
  | _So tedious..._ 
  | What will you do? ] 
{ Feed them.
   => You cast grain from the battlements.
      @peace
| Play some music.
   => No lute can drown their hungry groans.
      @revolt }
\end{verbatim}

The words ``{\em So tedious...}'' will disappear when a selection is made; being wrapped in underscores, they will also appear in italics, as a result of the Markdown-like macro transformation.
The prompt ``What will you do?'' will also disappear when a selection made.
(In multiplayer mode, the prompt is only shown to the active player.)



In the terminology of formal grammar theory: the scene label {\tt \@scene} is a {\em nonterminal symbol},
whereas other rendered text is composed of {\em terminal symbols} (ASCII characters).
Nonterminal symbols denote points in the text (scenes) where further expansion is possible;
terminal symbols denote static endpoints of the text.

All nonterminal symbols begin with {\tt \@}.
Special characters {\tt \$\@[\{\}]} can be escaped with a backslash if required in the text.
Quotation marks and other common punctuation are not special characters and can be used directly, as can HTML tags.
Some syntactic sugar for HTML tags (e.g. flanking underscores for italics) is borrowed from Markdown \cite{Markdown}.

Starting from an initial designated nonterminal (named {\tt @start} by default),
iterated application of these rules generates a {\em parse tree},
with nonterminal symbols at internal nodes and terminal symbols at the tips.
The final text can be read off from the terminals at the leaf nodes.

The sequence of terminals is post-processed before being rendered,
so the terminals themselves do not necessarily correspond exactly to what is shown on screen
(rather, it is more accurate to think of the expanded parse tree as specifying a final {\em program text}
that then deterministically computes the {\em story text} presented to the player).
As noted above, a Markdown-like macro expansion is applied to all terminal text, for quick HTML styling \cite{Markdown}.
The post-processor also allows scoped variable substitutions,
offering (in grammar-theroteic terms) a limited amount of {\em context-sensitivity}
to the otherwise context-free grammar.

Extra keywords are available; for example, to specify that some variables are directly controlled by the player,
(using sliders), or to delineate a variable as the score.
Other keywords can specify the game title, or control the behavior of the ``undo'' button.

Not all transformation rules need be presented to the player at every opportunity.
The designer can flag individual rules as hidden from view some fixed number of times
before first being shown, or limited to some finite number of uses.
Various modifier keywords can be associated with nonterminals to indicate this in the game source file.

More computationally expressive logic for controlling story flow is available via the use of computer players.
For nonterminals that are flagged as belonging to the computer player,
rules are normally played at random,
but this behavior can be manipulated by the designer to
assign different probabilistic weights to the rules
(and these weights can also be boolean logic expressions, allowing for more sophisticated control of flow).
The player can also ``steer'' the computer player by manipulating probabilistic weight parameters directly,
by means of slider controls in the HTML page.

\subsection{Editor}

FIGURE

Bottom line is a text edit box where game source can be edited directly.
A number of UI elements are presented that afford an Interactive Development Environment (IDE) to assist editing.

Drag-and-drop-sortable list of nonterminal panes.
Each nonterminal pane contains a drag-and-drop-sortable list of transformation rules.

Quick-reference text summaries of orphan nonterminals, bare nonterminals, empty rules.

Drag-and-drop-sortable list of sliders.

Hyperlink navigation to incoming/outgoing nonterminals, also to map.

\subsection{Map}

FIGURE

Map is visualized using graph library.
Nodes: nonterminals (arranged in circular layout).
Edges: existence of edge $a \to b$ implies some rule from $a$ that generates (at least) $b$.

Click on a node to show incoming \& outgoing edges.

\subsection{Parse tree viewer}

FIGURE

Parse tree is visualized using graph library.
Type and status of nodes indicated via size and coloring (terminals, expanded/unexpanded nonterminals, expanded/unexpanded computer-controlled nonterminals, parameter references/assignments/inputs).
Mouseover node for more info, click for shortcut to editor.

\subsection{Game client}

Rendering of tree with minimal, discreet styling and animation (e.g. fade-in).

``Undo'' button with gradually-increasing recharge time is offered as an optional game mechanic for solo play.

\subsection{Multiplayer operation}

Publish-subscribe model.
Invitation channel.
Play channel: hierarchically-structured channels, one channel for each node of parse tree.
Discreet animations conveying (a) successful publication of rule expansion to server, (b) successful server subscription at a given placeholder, listening for remote player choice.

\section{Discussion}

Structured chat-room?
Scripted interactive date?
Dungeonmaster-player?
Many possibilities...


\subsection{Cryptographic play}

Sketch of crypto-signed play.

Crucial messages can be signed (and counter-signed when received): invitations, applications to join the game, expansions of nodes in the parse tree.
No need for central authority.

\subsection{Optimal strategies}

Strategically optimal algorithms for playing this kind of game are known to exist when the scoring scheme is extremely predictable (e.g. linear in nonterminal usage \cite{DBLP:conf/icalp/EtessamiWY08}).
However, the scoring scheme described here is considerably more flexible, modeling many aspects of context-sensitive grammars as well as CFGs.

The programming language for the computer player does not attempt to model AI in any deep sense:
it is very simple, just offering variables, conditional tests, and the in-built facility for looping and recursion that comes for free with the CFG.

A theoretical extension is to use an ambiguous grammar (multiple parse trees consistent with observed output)
and introduce a computer player that can parse the current output (e.g. using Earley \cite{Stolcke}) and predict future outcomes.

\subsection{Implementation}

JavaScript, SigmaJS, PegJS, JQuery, OpenPGP, Node, Faye.

Early choose-your-own story prototype developed using Scheme.
Prototype of parser-based play developed using Perl.


\subsection{Availability}

{\tt https://github.com/ihh/funkscene}

\section{References}

%Recursive Stochastic Games with Positive Rewards. Etessami, Wojtczak, Yannakakis. Automata, Languages and Programming. Lecture Notes in Computer Science Volume 5125, 2008, pp 711-723

\bibliography{lwpaper}

\balancecolumns
% That's all folks!
\end{document}
